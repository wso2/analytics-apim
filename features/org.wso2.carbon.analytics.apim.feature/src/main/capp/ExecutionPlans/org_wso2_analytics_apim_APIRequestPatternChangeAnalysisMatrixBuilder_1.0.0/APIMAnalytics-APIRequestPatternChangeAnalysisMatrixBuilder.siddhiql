/* Enter a unique ExecutionPlan */
@Plan:name('APIMAnalytics-APIRequestPatternChangeAnalysisMatrixBuilder')


@Plan:trace('false')


@Import('org.wso2.analytics.apim.transitionStream:1.0.0')
define stream transitionStream (firstState string, nextState string, consumerKey string, userid string, requestTimestamp string);

@from(eventtable = 'analytics.table' , table.name = 'FIRSTCOUNTTABLE',  primary.keys = 'firstState,consumerKey', indices = 'firstState, count, consumerKey')
define table firstCountTable (firstState string, consumerKey string, count double);

@from(eventtable = 'analytics.table' , table.name = 'MARKOVMODELTABLE',  primary.keys = 'consumerKey.firstState,nextState', indices = 'firstState,nextState, count, probability, consumerKey')
define table MarkovModelTable (consumerKey string, firstState string, nextState string, count double, probability double);



/* ====== update count in firstcount table ======= */

from transitionStream as t left outer join firstCountTable
on (firstState == firstCountTable.firstState and consumerKey == firstCountTable.consumerKey)
select t.firstState, t.consumerKey, ifThenElse(firstCountTable.count is null,1.0,firstCountTable.count+1) as count
insert into firstCountTableStream;


from firstCountTableStream [count != 1.0]
update firstCountTable
on  (firstState == firstCountTable.firstState and consumerKey == firstCountTable.consumerKey);

from firstCountTableStream [count == 1.0]
select *
insert into firstCountTable;



/* ====== update count in markovmodel table ========= */ 

from transitionStream as t left outer join MarkovModelTable
on (firstState==MarkovModelTable.firstState and nextState == MarkovModelTable.nextState and consumerKey == MarkovModelTable.consumerKey)
select  t.consumerKey,t.firstState, t.nextState, ifThenElse(MarkovModelTable.count is null,1.0,MarkovModelTable.count+1) as count, 
ifThenElse(MarkovModelTable.probability is null,0.0,MarkovModelTable.probability) as probability
insert into MarkovModelTableStream;

from MarkovModelTableStream [count != 1.0]
update MarkovModelTable
on (firstState==MarkovModelTable.firstState and nextState == MarkovModelTable.nextState and consumerKey == MarkovModelTable.consumerKey);


from MarkovModelTableStream [count == 1.0]
select *
insert into MarkovModelTable;


/* == correlate firstcount table and markovmodel table == */

-- delay event to make sure "FirstCountTable & MarkovModeltable are updated
from transitionStream#window.time(3 sec)
select * 
insert expired events into transitionStreamAddedDelay;

from transitionStreamAddedDelay as t join firstCountTable
on (t.firstState == firstCountTable.firstState and t.consumerKey == firstCountTable.consumerKey)
select t.firstState, t.nextState, t.consumerKey, firstCountTable.count
insert into temp;

from temp as t join MarkovModelTable
on (t.firstState == MarkovModelTable.firstState and t.consumerKey == MarkovModelTable.consumerKey)
select MarkovModelTable.nextState, MarkovModelTable.consumerKey, MarkovModelTable.firstState, MarkovModelTable.count, t.count as firstCount, (MarkovModelTable.count/t.count) as probability
insert into tempStream;

from tempStream
select nextState, consumerKey, firstState, count, probability
insert into MarkovUpdateStream;

-- ==== update all rows with same transistions ====
from MarkovUpdateStream
update MarkovModelTable
on (firstState == MarkovModelTable.firstState and nextState == MarkovModelTable.nextState and consumerKey == MarkovModelTable.consumerKey);