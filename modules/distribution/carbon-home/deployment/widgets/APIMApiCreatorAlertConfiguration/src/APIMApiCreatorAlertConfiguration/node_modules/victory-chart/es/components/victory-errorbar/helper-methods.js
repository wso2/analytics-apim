import _sortBy from "lodash/sortBy";
import _flatten from "lodash/flatten";
import _isArray from "lodash/isArray";
import _defaults from "lodash/defaults";
import _omit from "lodash/omit";
import _assign from "lodash/assign";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

import { Helpers, LabelHelpers, Scale, Domain, Data } from "victory-core";

export default {
  getBaseProps: function (props, fallbackProps) {
    var _this = this;

    props = Helpers.modifyProps(props, fallbackProps, "errorbar");

    var _getCalculatedValues = this.getCalculatedValues(props, fallbackProps),
        data = _getCalculatedValues.data,
        style = _getCalculatedValues.style,
        scale = _getCalculatedValues.scale,
        domain = _getCalculatedValues.domain,
        origin = _getCalculatedValues.origin;

    var _props = props,
        groupComponent = _props.groupComponent,
        height = _props.height,
        width = _props.width,
        borderWidth = _props.borderWidth,
        standalone = _props.standalone,
        theme = _props.theme,
        polar = _props.polar,
        padding = _props.padding;

    var initialChildProps = { parent: {
        domain: domain, scale: scale, data: data, height: height, width: width, standalone: standalone, theme: theme, polar: polar, origin: origin,
        padding: padding, style: style.parent
      } };

    return data.reduce(function (childProps, datum, index) {
      var eventKey = datum.eventKey || index;
      var x = scale.x(datum._x1 !== undefined ? datum._x1 : datum._x);
      var y = scale.y(datum._y1 !== undefined ? datum._y1 : datum._y);

      var dataProps = {
        x: x, y: y, scale: scale, datum: datum, data: data, index: index, groupComponent: groupComponent, borderWidth: borderWidth,
        style: _this.getDataStyles(datum, style.data),
        errorX: _this.getErrors(datum, scale, "x"),
        errorY: _this.getErrors(datum, scale, "y")
      };

      childProps[eventKey] = {
        data: dataProps
      };
      var text = LabelHelpers.getText(props, datum, index);
      if (text !== undefined && text !== null || props.events || props.sharedEvents) {
        childProps[eventKey].labels = _this.getLabelProps(dataProps, text, style);
      }

      return childProps;
    }, initialChildProps);
  },
  getLabelProps: function (dataProps, text, style) {
    var x = dataProps.x,
        index = dataProps.index,
        scale = dataProps.scale,
        errorY = dataProps.errorY;

    var error = errorY && Array.isArray(errorY) ? errorY[0] : errorY;
    var y = error || dataProps.y;
    var labelStyle = style.labels || {};
    return {
      style: labelStyle,
      y: y - (labelStyle.padding || 0),
      x: x,
      text: text,
      index: index,
      scale: scale,
      datum: dataProps.datum,
      data: dataProps.data,
      textAnchor: labelStyle.textAnchor,
      verticalAnchor: labelStyle.verticalAnchor || "end",
      angle: labelStyle.angle
    };
  },
  getErrorData: function (props) {
    if (props.data) {
      if (props.data.length < 1) {
        return [];
      }

      return this.formatErrorData(props.data, props);
    } else {
      var generatedData = (props.errorX || props.errorY) && this.generateData(props);
      return this.formatErrorData(generatedData, props);
    }
  },
  getErrors: function (datum, scale, axis) {
    /**
     * check if it is asymmetric error or symmetric error, asymmetric error should be an array
     * and the first value is the positive error, the second is the negative error
     * @param  {Boolean} isArray(errorX)
     * @return {String or Array}
     */

    var errorNames = { x: "errorX", y: "errorY" };
    var errors = datum[errorNames[axis]];
    if (errors === 0) {
      return false;
    }

    return _isArray(errors) ? [errors[0] === 0 ? false : scale[axis](errors[0] + datum["_" + axis]), errors[1] === 0 ? false : scale[axis](datum["_" + axis] - errors[1])] : [scale[axis](errors + datum["_" + axis]), scale[axis](datum["_" + axis] - errors)];
  },
  formatErrorData: function (dataset, props) {
    if (!dataset) {
      return [];
    }
    var accessor = {
      x: Helpers.createAccessor(props.x !== undefined ? props.x : "x"),
      y: Helpers.createAccessor(props.y !== undefined ? props.y : "y"),
      errorX: Helpers.createAccessor(props.errorX !== undefined ? props.errorX : "errorX"),
      errorY: Helpers.createAccessor(props.errorY !== undefined ? props.errorY : "errorY")
    };

    var replaceNegatives = function (errors) {
      // check if the value is negative, if it is set to 0
      var replaceNeg = function (val) {
        return !val || val < 0 ? 0 : val;
      };
      return _isArray(errors) ? errors.map(function (err) {
        return replaceNeg(err);
      }) : replaceNeg(errors);
    };

    var stringMap = {
      x: Data.createStringMap(props, "x"),
      y: Data.createStringMap(props, "y")
    };

    return this.sortData(dataset.map(function (datum, index) {
      var evaluatedX = accessor.x(datum);
      var evaluatedY = accessor.y(datum);
      var _x = evaluatedX !== undefined ? evaluatedX : index;
      var _y = evaluatedY !== undefined ? evaluatedY : datum;
      var errorX = replaceNegatives(accessor.errorX(datum));
      var errorY = replaceNegatives(accessor.errorY(datum));

      return _assign({}, datum, { _x: _x, _y: _y, errorX: errorX, errorY: errorY },
      // map string data to numeric values, and add names
      typeof _x === "string" ? { _x: stringMap.x[_x], x: _x } : {}, typeof _y === "string" ? { _y: stringMap.y[_y], y: _y } : {});
    }), props.sortKey);
  },
  sortData: function (dataset, sortKey) {
    if (!sortKey) {
      return dataset;
    }

    if (sortKey === "x" || sortKey === "y") {
      sortKey = "_" + sortKey;
    }

    return _sortBy(dataset, sortKey);
  },
  getDomain: function (props, axis) {
    var propsDomain = Domain.getDomainFromProps(props, axis);
    if (propsDomain) {
      return Domain.padDomain(propsDomain, props, axis);
    }
    var categoryDomain = Domain.getDomainFromCategories(props, axis);
    if (categoryDomain) {
      return Domain.padDomain(categoryDomain, props, axis);
    }
    var dataset = this.getErrorData(props);

    if (dataset.length < 1) {
      return Scale.getBaseScale(props, axis).domain();
    }

    var domain = this.getDomainFromData(props, axis, dataset);
    return Domain.cleanDomain(Domain.padDomain(domain, props, axis), props);
  },
  getDomainFromData: function (props, axis, dataset) {
    var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);
    var error = void 0;
    if (currentAxis === "x") {
      error = "errorX";
    } else if (currentAxis === "y") {
      error = "errorY";
    }
    var axisData = _flatten(dataset).map(function (datum) {
      return datum["_" + currentAxis];
    });
    var errorData = _flatten(_flatten(dataset).map(function (datum) {
      var errorMax = void 0;
      var errorMin = void 0;
      if (_isArray(datum[error])) {
        errorMax = datum[error][0] + datum["_" + currentAxis];
        errorMin = datum["_" + currentAxis] - datum[error][1];
      } else {
        errorMax = datum[error] + datum["_" + currentAxis];
        errorMin = datum["_" + currentAxis] - datum[error];
      }
      return [errorMax, errorMin];
    }));

    var allData = axisData.concat(errorData);
    var min = Math.min.apply(Math, _toConsumableArray(allData));
    var max = Math.max.apply(Math, _toConsumableArray(allData));
    // TODO: is this the correct behavior, or should we just error. How do we
    // handle charts with just one data point?
    if (+min === +max) {
      return Domain.getSinglePointDomain(max);
    }
    return [min, max];
  },
  getCalculatedValues: function (props) {
    var defaultStyles = props.theme && props.theme.errorbar && props.theme.errorbar.style ? props.theme.errorbar.style : {};
    var style = Helpers.getStyles(props.style, defaultStyles) || {};
    var dataWithErrors = _assign(Data.getData(props), this.getErrorData(props));
    var data = Data.addEventKeys(props, dataWithErrors);
    var range = {
      x: Helpers.getRange(props, "x"),
      y: Helpers.getRange(props, "y")
    };
    var domain = {
      x: this.getDomain(props, "x"),
      y: this.getDomain(props, "y")
    };
    var scale = {
      x: Scale.getBaseScale(props, "x").domain(domain.x).range(range.x),
      y: Scale.getBaseScale(props, "y").domain(domain.y).range(range.y)
    };
    var origin = props.polar ? props.origin || Helpers.getPolarOrigin(props) : undefined;
    return { domain: domain, data: data, scale: scale, style: style, origin: origin };
  },
  getDataStyles: function (datum, style) {
    var stylesFromData = _omit(datum, ["x", "y", "name", "errorX", "errorY", "eventKey"]);
    return _defaults({}, stylesFromData, style);
  }
};